{"/Linux/Licheepi_Nano/系统编译/编译U-boot.html": {"title": "编译U-BOOT", "content": "---\ntitle: 编译U-BOOT\ntags: teedoc, markdown, 语法\nkeywords: teedoc, markdown, 语法\ndesc: teedoc 的 markdown 语法介绍和实例\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_nano/build_system/u-boot/\n---\n\n\n\n> 下载荔枝派u-boot\n\n```\ngit clone https://gitee.com/LicheePiNano/u-boot.git\ncd u-boot\n\n# 查看分支\ngit branch -a\n# 切换到 Nano 分支\ngit checkout nano-lcd800480\n```\n\n> 去掉官方写死在文件中的bootcmd，此步骤可忽略，因为目标也是编译出针对flash的u-boot，只是为了通用，将写死的配置去掉，在menuconfig中配置\n\n```\ninclude/configs/suniv.h\n\n注释掉以下内容\n#define CONFIG_BOOTCOMMAND   \"sf probe 0 50000000; \"                    \\\n                     \"sf read 0x80C00000 0x100000 0x4000; \"  \\\n                     \"sf read 0x80008000 0x110000 0x400000; \" \\\n                     \"bootz 0x80008000 - 0x80C00000\"\n```\n\n> 加载荔枝派官方的flash配置文件\n\n```\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- licheepi_nano_spiflash_defconfig\n```\n\n> 打开可视化配置界面，配置bootcmd 和 bootarg\n\n```\nmake ARCH=arm menuconfig\n\n#root=/dev/mmcblk0p1为文件系统的路径，设置为TF卡\n#TF卡插入后，\n[*] Enable boot arguments\n\tconsole=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p1 earlyprintk rw\n\t\n#分别设置从flash的哪个位置加载dtb和zimage\n[*] Enable a default value for bootcmd\n\tsf probe 0 50000000;sf read 0x80C00000 0x100000 0x4000;sf read 0x80008000 0x110000 0x400000;bootz 0x80008000 - 0x80C00000\n```\n\n> 开始编译\n\n```\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j8\n```\n\n> 烧录u-boot\n\n```\nsunxi-fel -p spiflash-write 0 ./u-boot-sunxi-with-spl.bin\n```"}, "/Linux/Licheepi_Nano/系统编译/编译Linux.html": {"title": "编译Linux", "content": "---\ntitle: 编译Linux\ntags: teedoc, markdown, 语法\nkeywords: teedoc, markdown, 语法\ndesc: teedoc 的 markdown 语法介绍和实例\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_nano/build_system/linux/\n---\n\n\n> 下载，编译\n\n```\ngit clone https://gitee.com/LicheePiNano/Linux.git\n\nmake ARCH=arm f1c100s_nano_linux_defconfig\n\nmake ARCH=arm menuconfig\n\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j8\n\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16 INSTALL_MOD_PATH=out modules\n\nmake ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16 INSTALL_MOD_PATH=out modules_install\n```\n\n> 烧录\n\nu-boot的bootcmd中，写入内容如下\n\n```\n#类似连接flash\nsf probe 0 50000000; \n\n#从flash的0x100000地址读取0x4000长度的数据到内存0x80c00000\n#即从flash的1M地址出读取16kb的内容到内存中，这部分内容为内核的dtb文件\nsf read 0x80C00000 0x100000 0x4000; \n\n#从flash的0x110000地址读取0x400000长度的数据到内存0x80008000\n#即从flash的1088K地址出读取4Mb的内容到内存中，这部分内容为内核的zImage文件\nsf read 0x80008000 0x110000 0x400000;\n\n#从内存的0x80008000启动内核\nbootz 0x80008000 - 0x80C00000\n```\n\n> 所以\n>\n> zImage 应该写入 flash的1088K处\n>\n> suniv-f1c100s-licheepi-nano.dtb 应该写入flash的 1M处\n\n```\nsunxi-fel -p spiflash-write 0x100000 ./arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dtb\nsunxi-fel -p spiflash-write 0x110000 ./arch/arm/boot/zImage\n```"}, "/Linux/Licheepi_Nano/系统编译/编译BuildRoot.html": {"title": "编译BuildRoot", "content": "---\ntitle: 编译BuildRoot\ntags: teedoc, markdown, 语法\nkeywords: teedoc, markdown, 语法\ndesc: teedoc 的 markdown 语法介绍和实例\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_nano/build_system/buildroot/\n---\n\n下载解压 buildroot\n\n```\nwget https://buildroot.org/downloads/buildroot-2021.02.4.tar.gz\n\ntar xvf buildroot-2021.02.4.tar.gz\n\ncd LicheePi_Nano/buildroot-2021.02.4\n```\n\n> 配置\n\n```\nmake menuconfig\n\n- Target options\n  - Target Architecture (ARM (little endian))\n  - Target Variant arm926t\n  \n- Toolchain\n  - C library (glibc) # 使用glibc后，u-boot，linux，rootfs加起来的大小会超过flash16M，所以需要将rootfs放在TF卡中，但是glic比较通用，开发app比较方便，高手可以选其他\n  \n- System configuration\n  - Use syslinks to /usr .... # 启用/bin, /sbin, /lib的链接\n  - Enable root login # 启用root登录\n  - Run a getty after boot # 启用登录密码输入窗口\n  \n  #因为荔枝派官方的内核版本为4.15，所以需要在buildroot中指定比这个低的才行\n- buildroot\n\t- toolchain\n\t\t-kernel headers\n\t\t\t-4.14.x\n```\n\n> 烧录\n\n```\n因为flash的剩余空间不足以存放rootfs，所以将rootfs放在TF卡中，前面编译u-boot也已经设置为从tf卡加载文件系统\n```\n\n1. TF卡分区，只分一个区，从tf的开头开始\n\n   ```\n   gparted工具分区\n   ```\n\n2. 解压rootfs到tf卡\n\n   ```\n   tar -xvf buildroot-2021.02.4/output/images/rootfs.tar -C /media/xsx/rootfs/\n   ```"}, "/Linux/Licheepi_Nano/说明.html": {"title": "README", "content": "---\ntitle: README\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_nano/desc/\n---\nsac"}, "/Linux/Licheepi_Nano/驱动/GPIO驱动/基于设备树.html": {"title": "基于设备树", "content": "---\ntitle: 基于设备树\ntags: teedoc, markdown, 语法\nkeywords: teedoc, markdown, 语法\ndesc: teedoc 的 markdown 语法介绍和实例\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_nano/driver/led/devicetree/\n---\n\n设备树路径：/arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dts \n在根节点下面添加LED节点\n```\nmy_led {\n\t\tcompatible = \"xsx,led_a0\";\n\t\t#address-cells = <1>;\n\t\t#size-cells = <1>;\n\t\treg = <0X01C20800 0x04 0X01C20810 0x04>;\n\t\tstatus = \"okay\";\n\t};\n\n#控制PA0的寄存器只需要两个，所以reg中的寄存器地址意义如下\nPa_CFG0:  0x01c20800\nPa_DATA: 0x01c20810\n```\n\n\n添加驱动c文件：/drivers/leds/my_led.c\n```\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/init.h>       \n#include <linux/uaccess.h>\n#include <asm/io.h>          //含有ioremap函数iounmap函数\n#include <asm/uaccess.h>     //含有copy_from_user函数和含有copy_to_user函数\n#include <linux/device.h>    //含有类相关的设备函数\n#include <linux/cdev.h>\n#include <linux/of.h>\n\n\nstatic dev_t led_dev_num;   //定义一个设备号\nstatic struct cdev * led_dev;   \nstatic struct class * led_class;\nstatic struct device * led0;\n\nsize_t * gpioa_cfg0;\nsize_t * gpioa_data;\n\nstatic int led_open(struct inode * inode, struct file * file)\n{\n    /* GPIOA配置 */ \n    *((volatile size_t*)gpioa_cfg0) &= ~(7<<0); //清除配置寄存器 \n    *((volatile size_t*)gpioa_cfg0) |= (1<<0); //配置GPIOE10为输出模式 \n    printk(KERN_DEBUG\"open led!!!\\n\"); \n    return 0;\n}\n\nstatic int led_close(struct inode *inode, struct file *filp)\n{\n    printk(KERN_DEBUG\"close led!!!\\n\");\n    return 0;\n}\n\n\nstatic int led_read(struct file *filp, char __user *buff, size_t count, loff_t *offp)\n{\n    return 0;\n}\n\n\nstatic int led_write(struct file *filp, const char __user *buff, size_t count, loff_t *offp)\n{\n    int ret;\n    size_t status; \n    ret = copy_from_user(&status,buff,4);     //将用户空间拷贝到内核空间的status\n    if(ret < 0)\n        printk(KERN_DEBUG\"write error!!!\\n\");   //输出信息\n    else\n        printk(KERN_DEBUG\"write led ok!!!\\n\");   //输出信息\n    *((volatile size_t*)gpioa_data) &= ~(1<<0) ;//清除GPIOE12状态\n    if(status == 1)\n        *((volatile size_t*)gpioa_data) |= (1<<0);//设置GPIOE12状态1\n    return ret;\n}\n\nstatic struct file_operations led_ops = \n{\n        .owner = THIS_MODULE,\n        .open  = led_open,\n        .read  = led_read,\n        .write = led_write,\n        .release = led_close,\n};\n\nstatic int __init led_init(void)   \n{\n    int ret;\n\n\tu32 GPIOA_CFG0;\n\tu32 GPIOA_DATA;\nstruct device_node * led_node;\n\n    led_dev = cdev_alloc();    //动态申请一个设备结构体\n    if(led_dev == NULL)\n    {\n        printk(KERN_WARNING\"cdev_alloc failed!\\n\");\n        return -1;\n    }\n    ret = alloc_chrdev_region(&led_dev_num,0,1,\"led\");  //动态申请一个设备号\n    if(ret !=0)\n    {\n        printk(KERN_WARNING\"alloc_chrdev_region failed!\\n\");\n        return -1;\n    }\n    led_dev->owner = THIS_MODULE;  //初始化设备管理结构体的owner为THIS_MODULE\n    led_dev->ops = &led_ops;        //初始化设备操作函数指针为led_ops函数\n    cdev_add(led_dev,led_dev_num,1);  //将设备添加到内核中\n    led_class = class_create(THIS_MODULE, \"led_class\");  //创建一个名为led_class的类  /sys/class\n    if(led_class == NULL)\n    {\n        printk(KERN_WARNING\"led_class failed!\\n\");\n        return -1;\n    }\n    led0 = device_create(led_class,NULL,led_dev_num,NULL,\"led_a0\");//创建一个设备名为led0 /dev/led0\n    if(IS_ERR(led0))\n    {\n        printk(KERN_WARNING\"device_create failed!\\n\");\n        return -1;\n    }\n\t\n\tled_node = of_find_node_by_path(\"/my_led\");\n\tif(led_node == NULL)\n\t{\n        \tprintk(KERN_WARNING\"no led node!\\n\");\n        \treturn -1;\n   \t }\n\n\tif(of_property_read_u32_index(led_node, \"reg\", 0, &GPIOA_CFG0))\n\t{\n        \tprintk(KERN_WARNING\"read reg fail!\\n\");\n        \treturn -1;\n   \t }\nif(of_property_read_u32_index(led_node, \"reg\", 1, &GPIOA_DATA))\n\t{\n        \tprintk(KERN_WARNING\"read reg fail!\\n\");\n        \treturn -1;\n   \t }\n\n    gpioa_cfg0 = ioremap(GPIOA_CFG0,4);  //将GPIOE_CFG0物理地址映射为虚拟地址\n    gpioa_data = ioremap(GPIOA_DATA,4);  //将GPIOE_DATA物理地址映射为虚拟地址\n    return 0;\n}\n\nstatic void __exit led_exit(void)   \n{\n    cdev_del(led_dev);  //从内核中删除设备管理结构体\n    unregister_chrdev_region(led_dev_num,1);  //注销设备号\n    device_destroy(led_class,led_dev_num);   //删除设备节点\n    class_destroy(led_class);                //删除设备类\n    iounmap(gpioa_cfg0);  //取消GPIOE_CFG0映射\n    iounmap(gpioa_data);  //取消GPIOE_DATA映射\n}\n\nmodule_init(led_init);\nmodule_exit(led_exit);\n\nMODULE_LICENSE(\"GPL\");          //不加的话加载会有错误提醒\nMODULE_AUTHOR(\"1477153217@qq.com\");     //作者\nMODULE_VERSION(\"0.1\");          //版本\nMODULE_DESCRIPTION(\"led_dev\");  //简单的描述\n\n```"}, "/Linux/Licheepi_Nano/驱动/GPIO驱动/基于platform总线.html": {"title": "基于Platform驱动模型", "content": "---\ntitle: 基于Platform驱动模型\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_nano/driver/led/platform/\n---\n## 编写设备树\n\n```\nplatform_led {\n\t\tcompatible = \"xsx,platform_led_dri\";\n\t\t#address-cells = <1>;\n\t\t#size-cells = <1>;\n\t\treg = <0X01C20800 0x04 0X01C20810 0x04>;\n\t\tstatus = \"okay\";\n\t};\n```\n\n## 编写驱动\n\n```\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n\nstatic dev_t led_dev_num;         // 定义一个设备号\nstatic struct cdev *led_cdev;     // 定义一个设备管理结构体指针\nstatic struct class *led_class;   // 定义一个设备类\nstatic struct device *led_device; // 定义一个设备\n\nvolatile unsigned long *gpio_a_cfg0;\nvolatile unsigned long *gpio_a_data;\n\nstatic int led_open(struct inode *inode, struct file *file)\n{\n    *((volatile size_t *)gpio_a_cfg0) &= ~(7 << 0); // 清除配置寄存器\n    *((volatile size_t *)gpio_a_cfg0) |= (1 << 0);  // 配置GPIOE10为输出模式\n\n    return 0;\n}\n\nstatic int led_close(struct inode *inode, struct file *file)\n{\n    return 0;\n}\n\nstatic int led_read(struct file *filp, char __user *buff, size_t count, loff_t *off)\n{\n    int res;\n    size_t status = *((volatile size_t *)gpio_a_data);\n\n    // 将内核空间数据拷贝到用户空间\n    // statue => buff, 大小4字节\n    res = copy_to_user(buff, &status, 4);\n    if (res < 0)\n        printk(KERN_DEBUG \"read error!!!\\r\\n\");\n    else\n        printk(KERN_DEBUG \"read ok!!!\\r\\n\");\n\n    return res;\n}\n\nstatic int led_write(struct file *filp, const char __user *buff, size_t count, loff_t *offp)\n{\n    int res = 0;\n    size_t statue = 0;\n\n    res = copy_from_user(&statue, buff, 4);\n    if (res < 0)\n    {\n        printk(KERN_DEBUG \"write error!!!\\r\\n\");\n        return 0;\n    }\n\n    if (!!statue)\n        *((volatile size_t *)gpio_a_data) |= (1 << 0);\n    else\n        *((volatile size_t *)gpio_a_data) &= ~(1 << 0);\n\n    return 1;\n}\n\nstatic struct file_operations led_ops = {\n    .owner = THIS_MODULE,\n    .open = led_open,\n    .read = led_read,\n    .write = led_write,\n    .release = led_close,\n};\n\nstatic int led_probe(struct platform_device * pdev)\n{\n    struct resource * res;\n    int ret;\n\n    led_cdev = cdev_alloc();    //动态申请一个设备结构体\n    if(led_cdev == NULL) {\n        printk(KERN_WARNING \"cdev alloc fail!!\\r\\b\");\n        return -1;\n    }\n\n    ret = alloc_chrdev_region(&led_dev_num, 0, 1, \"led_num\");//动态申请一个设备号\n    if(ret != 0) {\n        printk(KERN_WARNING \"alloc_chrdev_region fail!!\\r\\b\");\n        return -2;\n    }\n\n    led_cdev->owner = THIS_MODULE;\n    led_cdev->ops = &led_ops;\n    cdev_add(led_cdev, led_dev_num, 1);    //将设备添加到内核中\n\n    led_class = class_create(THIS_MODULE, \"led_class\");\n    if(led_class == NULL) {\n        printk(KERN_WARNING \"class_create fail!!\\r\\b\");\n        return -3;\n    }\n\n//这个名字会作为驱动设备的文件名\n    led_device = device_create(led_class, NULL, led_dev_num, NULL, \"led_device\");\n    if(IS_ERR(led_device)) {\n        printk(KERN_WARNING \"device_create fail!!\\r\\b\");\n        return -4;\n    }\n\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    gpio_a_cfg0 = ioremap(res->start, res->end - res->start + 1);\n\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n    gpio_a_data = ioremap(res->start, res->end - res->start + 1);\n\n    return 0;\n}\n\nstatic int led_remove(struct platform_device * pdev)\n{\n    iounmap(gpio_a_cfg0);\n    iounmap(gpio_a_data);\n\n    cdev_del(led_cdev);\n    unregister_chrdev_region(led_dev_num, 1);\n    device_destroy(led_class, led_dev_num);\n    class_destroy(led_class);\n\n    return 0;\n}\n\n//优先级高：匹配设备树中compatible属性全部\nstatic struct of_device_id led_match_table[]={\n    {\n        .compatible = \"xsx,platform_led_dri\",\n    },\n    {},\n};\n//优先级低于of_match_table：匹配设备树中compatible属性中的设备名\nstatic struct platform_device_id led_device_ids[]={\n    {\n        .name=\"platform_led_dri\",\n    },\n    {},\n};\n\nstatic struct platform_driver led_driver={\n    .probe = led_probe,\n    .remove = led_remove,\n    .driver = {\n        .name = \"led\",\n        .of_match_table = led_match_table,\n    },\n    .id_table = led_device_ids,\n};\n\nstatic int led_driver_init(void)\n{\n    platform_driver_register(&led_driver);\n\n    return 0;\n}\n\nstatic void led_driver_exit(void){\n    platform_driver_unregister(&led_driver);\n}\n\nmodule_init(led_driver_init);\nmodule_exit(led_driver_exit);\n\nMODULE_LICENSE(\"GPL\");          //不加的话加载会有错误提醒\nMODULE_AUTHOR(\"1477153217@qq.com\");     //作者\nMODULE_VERSION(\"0.1\");          //版本\nMODULE_DESCRIPTION(\"led_driver\");  //简单的描述\n\n```\n\n```\n#在makefile中加入\nobj-y\t\t+= xsx_platform_led.o\n\n#然后编译烧录系统即可在/dev下发现led_device文件\n```\n\n\n\n## 测试程序\n\n```\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\nint main(int argc, char **argv)\n{\n    int fd;\n    char *filename = NULL;\n    int val, cnt, i;\n\n    filename = argv[1];\n    fd = open(filename, O_RDWR);\n    if (fd < 0)\n    {\n        printf(\"err, can`t open %s\\r\\n\", filename);\n        return 0;\n    }\n\n    if (argc != 3)\n    {\n        printf(\"usage: ./led_app.exe [device] [次数]\\r\\n\");\n    }\n\n    cnt = strtol(argv[2], NULL, 10);\n    for (i = 0; i < cnt; i++)\n    {\n        val = 0;\n        write(fd, &val, 4);\n        sleep(1);\n\n        val = 1;\n        write(fd, &val, 4);\n        sleep(1);\n    }\n\n    close(fd);\n    return 0;\n}\n```\n\n```\n#编译app\narm-linux-gcc led_test.c -o led_test_app.o\n\n#下载到板子上\nchmod 777 ./led_test_app.o\n./led_test_app.o /dev/led_device 10\nLED即可闪烁10次\n```"}, "/Linux/Licheepi_Nano/驱动/GPIO驱动/寄存器GPIO驱动.html": {"title": "寄存器GPIO驱动", "content": "---\ntitle: 寄存器GPIO驱动\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_nano/driver/led/gpio/\n---\n\n## 目标\n\n​\t编写驱动，控制PA0输出高低电平。\n\n\n\n## F1C100S硬件接口\n\n> 查找PA0的寄存器\n\n![](./assets/pa_reg.png)\n\n![](./assets/pa_reg2.png)\n\n\n\n> 通过上面寄存器发现，PA只有PA0-PA3可用作普通IO\n>\n> 且只需要PA Configure register 0 和 PA Data register 即可控制IO\n\n\n\n![](./assets/gpio.png)\n\n> GPIO基础地址：0x01c20800\n>\n> GPIOA基础地址：0*0x24 + 0x01c20800 = 0x01c20800\n>\n> ​\t\tPa_CFG0:  0*0x24 + 0 + 0x01c20800 = 0x01c20800\n>\n> ​\t\tPa_DATA: 0*0x24 + 0x10 + 0x01c20800 = 0x01c20810\n\n\n\n## 字符设备驱动\n\n### 驱动程序\n\nled.c\n\n```\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/init.h>       \n#include <linux/uaccess.h>\n#include <asm/io.h>          //含有ioremap函数iounmap函数\n#include <asm/uaccess.h>     //含有copy_from_user函数和含有copy_to_user函数\n#include <linux/device.h>    //含有类相关的设备函数\n#include <linux/cdev.h>\n\n#define GPIOA_CFG0  (0X01C20800)\n#define GPIOA_DATA  (0X01C20810)\n\nstatic dev_t led_dev_num;   //定义一个设备号\nstatic struct cdev * led_dev;   \nstatic struct class * led_class;\nstatic struct device * led0;\n\nsize_t * gpioa_cfg0;\nsize_t * gpioa_data;\n\nstatic int led_open(struct inode * inode, struct file * file)\n{\n    /* GPIOA配置 */ \n    *((volatile size_t*)gpioa_cfg0) &= ~(7<<0); //清除配置寄存器 \n    *((volatile size_t*)gpioa_cfg0) |= (1<<0); //配置GPIOE10为输出模式 \n    printk(KERN_DEBUG\"open led!!!\\n\"); \n    return 0;\n}\n\nstatic int led_close(struct inode *inode, struct file *filp)\n{\n    printk(KERN_DEBUG\"close led!!!\\n\");\n    return 0;\n}\n\n\nstatic int led_read(struct file *filp, char __user *buff, size_t count, loff_t *offp)\n{\n    return 0;\n}\n\n\nstatic int led_write(struct file *filp, const char __user *buff, size_t count, loff_t *offp)\n{\n    int ret;\n    size_t status; \n    ret = copy_from_user(&status,buff,4);     //将用户空间拷贝到内核空间的status\n    if(ret < 0)\n        printk(KERN_DEBUG\"write error!!!\\n\");   //输出信息\n    else\n        printk(KERN_DEBUG\"write led ok!!!\\n\");   //输出信息\n    *((volatile size_t*)gpioa_data) &= ~(1<<0) ;//清除GPIOE12状态\n    if(status == 1)\n        *((volatile size_t*)gpioa_data) |= (1<<0);//设置GPIOE12状态1\n    return ret;\n}\n\nstatic struct file_operations led_ops = \n{\n        .owner = THIS_MODULE,\n        .open  = led_open,\n        .read  = led_read,\n        .write = led_write,\n        .release = led_close,\n};\n\nstatic int __init led_init(void)   \n{\n    int ret;\n    led_dev = cdev_alloc();    //动态申请一个设备结构体\n    if(led_dev == NULL)\n    {\n        printk(KERN_WARNING\"cdev_alloc failed!\\n\");\n        return -1;\n    }\n    ret = alloc_chrdev_region(&led_dev_num,0,1,\"led\");  //动态申请一个设备号\n    if(ret !=0)\n    {\n        printk(KERN_WARNING\"alloc_chrdev_region failed!\\n\");\n        return -1;\n    }\n    led_dev->owner = THIS_MODULE;  //初始化设备管理结构体的owner为THIS_MODULE\n    led_dev->ops = &led_ops;        //初始化设备操作函数指针为led_ops函数\n    cdev_add(led_dev,led_dev_num,1);  //将设备添加到内核中\n    led_class = class_create(THIS_MODULE, \"led_class\");  //创建一个名为led_class的类  /sys/class\n    if(led_class == NULL)\n    {\n        printk(KERN_WARNING\"led_class failed!\\n\");\n        return -1;\n    }\n    led0 = device_create(led_class,NULL,led_dev_num,NULL,\"led_A0\");//创建一个设备名为led0 /dev/led0\n    if(IS_ERR(led0))\n    {\n        printk(KERN_WARNING\"device_create failed!\\n\");\n        return -1;\n    }\n    gpioa_cfg0 = ioremap(GPIOA_CFG0,4);  //将GPIOE_CFG0物理地址映射为虚拟地址\n    gpioa_data = ioremap(GPIOA_DATA,4);  //将GPIOE_DATA物理地址映射为虚拟地址\n    return 0;\n}\n\nstatic void __exit led_exit(void)   \n{\n    cdev_del(led_dev);  //从内核中删除设备管理结构体\n    unregister_chrdev_region(led_dev_num,1);  //注销设备号\n    device_destroy(led_class,led_dev_num);   //删除设备节点\n    class_destroy(led_class);                //删除设备类\n    iounmap(gpioa_cfg0);  //取消GPIOE_CFG0映射\n    iounmap(gpioa_data);  //取消GPIOE_DATA映射\n}\n\nmodule_init(led_init);\nmodule_exit(led_exit);\n\nMODULE_LICENSE(\"GPL\");          //不加的话加载会有错误提醒\nMODULE_AUTHOR(\"1477153217@qq.com\");     //作者\nMODULE_VERSION(\"0.1\");          //版本\nMODULE_DESCRIPTION(\"led_dev\");  //简单的描述\n\n```\n\n### makefile\n\n```\nKERN_DIR = /home/xsx/licheepi_nano_tf/Linux\n\nall:\n\tmake -C $(KERN_DIR) M=$(shell pwd) modules\n\nclean:\n\trm -rf *.order *o *.symvers *.mod.c *.mod *.ko\n\nobj-m += led.o \n```\n\n### 编译\n\n编译驱动要使用 u-boot和linux相同的编译链\n\n` make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- `\n\n会按照makefile的规则编译出led.ko\n\n\n\n## 测试程序\n\nled_app.c\n\n```\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\nint main(int argc, char **argv)\n{\n    int fd;\n    char *filename = NULL;\n    int val;\n\n    filename = argv[1];\n    fd = open(filename, O_RDWR);\n    if (fd < 0)\n    {\n        printf(\"err, can`t open %s\\r\\n\", filename);\n        return 0;\n    }\n\n    if (argc != 3)\n    {\n        printf(\"usage: ./led_app.exe [device] [on/off]\\r\\n\");\n    }\n\n    if (!strcmp(argv[2], \"on\"))\n    {\n        val = 0;\n    }\n    else if (!strcmp(argv[2], \"off\"))\n    {\n        val = 1;\n    }\n    else\n    {\n        printf(\"输入错误！\\r\\n\");\n        return 0;\n    }\n\n    write(fd, &val, 4);\n    close(fd);\n    return 0;\n}\n```\n\n### 编译\n\n编译测试程序需要用 buildroot 生成 的交叉编译链\n\n`arm-linux-gcc led_app.c -o led_app.exe`\n\n## 运行\n\n将led.ko 和 led_app.exe拷贝到开发板\n\n### 加载驱动\n\n`insmod led.ko`\n\n出现`loading out-of-tree module taints kernel.`，即表明加载成功\n\n### 运行测试程序\n\nled亮： `./led_app.exe /dev/led_A0 on`\n\nled灭： `./led_app.exe /dev/led_A0 off`\n\nled_A0 为led.c驱动代码中设置的设备名称，驱动加载后，会在/dev/下创建该驱动的文件"}}