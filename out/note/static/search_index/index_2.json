{"/note/Linux/Licheepi_Zero/应用开发/v3S编译QT5.html": {"title": "使用buildroot编译QT", "content": "---\ntitle: 使用buildroot编译QT\ntags: 编译V3S系统\nkeywords: 编译V3S系统\ndesc: 编译V3S系统\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_zero/app/build_qt5/\n---\n\n## 一.配置编译\n在buildroot下面，打开配置界面\n`make menuconfig`\n![](../assets/images/buildroot_qt_1.png)\n![](../assets/images/buildroot_qt_2.png)\n![](../assets/images/buildroot_qt_3.png)\n![](../assets/images/buildroot_qt_4.png)\n\n然后编译\n`make`\n\n将文件系统解压到第二分区\n`tar -xvf output/images/rootfs.tar -C /media/xsx/rootfs/`\n\n## 二.查看QT版本\n`output/build/qt5base-5.12.4/bin/qmake -v`\n![](../assets/images/buildroot_qt_5.png)\n可以看到我们的qt是5.15的\n\n## 三.运行一个demo\n例程都在\n`output/build/qt5base-5.12.4/examples/widgets/widgets/`\n使用qmake 编译数字时钟的例程\n```\ncd output/build/qt5base-5.15.2/examples/widgets/widgets/digitalclock/\n../../../../bin/qmake digitalclock.pro \nxsx@ubuntu:~/v3s/buildroot-2021.02.4/output/build/qt5base-5.15.2/examples/widgets/widgets/\n```\n\n查看生成了Makefile\n```\ndigitalclock$ ls\ndigitalclock.cpp  digitalclock.h  digitalclock.pro  main.cpp  Makefile\n```\n\n执行make\n```\nxsx@ubuntu:~/v3s/buildroot-2021.02.4/output/build/qt5base-5.15.2/examples/widgets/widgets/digitalclock$ make\n/home/xsx/v3s/buildroot-2021.02.4/output/host/bin/arm-linux-gnueabihf-g++ --sysroot=/home/xsx/v3s/buildroot-2021.02.4/output/host/arm-buildroot-linux-gnueabihf/sysroot -Wl,-O1 -Wl,--enable-new-dtags -o digitalclock .obj/digitalclock.o .obj/main.o .obj/moc_digitalclock.o   -latomic /home/xsx/v3s/buildroot-2021.02.4/output/build/qt5base-5.15.2/lib/libQt5Widgets.so /home/xsx/v3s/buildroot-2021.02.4/output/build/qt5base-5.15.2/lib/libQt5Gui.so /home/xsx/v3s/buildroot-2021.02.4/output/build/qt5base-5.15.2/lib/libQt5Core.so -lpthread  -lrt -lpthread -ldl \n```\n\n查看，已经生成可执行文件digitalclock\n```\nxsx@ubuntu:~/v3s/buildroot-2021.02.4/output/build/qt5base-5.15.2/examples/widgets/widgets/digitalclock$ ls\ndigitalclock      digitalclock.h    main.cpp\ndigitalclock.cpp  digitalclock.pro  Makefile\n```\n\n在sd卡第二分区建立调试文件夹xsx\n复制可执行文件digitalclock到此文件夹\n将sd卡上电\n```\ncd /xsx\n./digitalclock -platform linuxfb\n```\n即可看到屏幕显示数字时钟\n![](../assets/images/buildroot_qt_6.png)"}, "/note/Linux/Licheepi_Zero/系统编译.html": {"title": "编译V3S系统", "content": "---\ntitle: 编译V3S系统\ntags: 编译V3S系统\nkeywords: 编译V3S系统\ndesc: 编译V3S系统\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_zero_build_system/\n---\n\n## 交叉编译链工具安装\n* 工具下载地址，这里使用7.5版本的交叉编译链，建议迅雷下载\n`https://releases.linaro.org/components/toolchain/binaries/7.5-2019.12/arm-linux-gnueabihf/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf.tar.xz`\n\n\n* 下载完后，复制到ubuntu中\n* 解压\n  `tar -vxJf gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf.tar.xz`\n* 复制到系统目录\n  `sudo cp -r ./gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf /opt/`\n* 添加到系统环境变量\n    ```\n    #打开配置文件\n    sudo vim /etc/bash.bashrc\n    #在文件最后添加\n    PATH=\"$PATH:/opt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/bin\"\n    #使文件生效\n    source /etc/bash.bashrc\n    ```\n* 验证生效，重启\n    `arm-linux-gnueabihf-gcc -v`\n\n## U盘分区\n\n* 安装gparted工具\n  `sudo apt-get install gparted `\n\n* 分区1\n  从1M偏移处开始，大小32M，fat16格式\n\n* 分区2\n  剩余所有空间，exe4格式\n\n## 编译u-boot\n* 下载荔枝派u-boot\n  `git clone https://github.com/Lichee-Pi/u-boot.git -b v3s-current`\n* 修改 include/configs/sun8i.h, 使u-boot可以直接从tf卡启动\n  ```\n    #define CONFIG_BOOTCOMMAND   \"setenv bootm_boot_mode sec; \" \\\n                            \"load mmc 0:1 0x41000000 zImage; \"  \\\n                            \"load mmc 0:1 0x41800000 sun8i-v3s-licheepi-zero-dock.dtb; \" \\\n                            \"bootz 0x41000000 - 0x41800000;\"\n    #define CONFIG_BOOTARGS      \"console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw  vt.global_cursor_default=0\"\n    ```\n* 编译\n  ```\n  make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- LicheePi_Zero_800x480LCD_defconfig\n  make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8\n  ```\n* 烧录到TF卡\n  `sudo dd if=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8`\n* 此时插入TF启动，即可看到u-boot的启动信息\n\n## 编译linux\n* 下载linux\n  `git clone -b zero-5.2.y --depth 1 https://github.com/Lichee-Pi/linux.git`\n* 编译\n  ```\n  make ARCH=arm licheepi_zero_defconfig\n  make ARCH=arm menuconfig\n  make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8\n  ```\n\n* 将`arch/arm/boot/zImage`和`arch/arm/boot/dts/sun8i-v3s-licheepi-zero-dock.dtb`复制到SD卡的第一分区即可\n\n## 编译文件系统\n* 下载\n  ```\n  wget https://buildroot.org/downloads/buildroot-2021.02.4.tar.gz\n  tar xvf buildroot-2021.02.4.tar.gz\n  cd LicheePi_Nano/buildroot-2021.02.4\n  ```\n* 使用make menuconfig命令，来配置buildroot\n  1. target options\n      ![](./assets/images/buildroot_1.png)\n  2. 编译链设置，使用外部交叉编译链，即编译u-boot和kernel的编译链，这样的好处是u-boot、kernel、rootfs、app全部都可以使用此编译链\n      ![](./assets/images/buildroot_2.png)\n      ```\n      #设置使用外部交叉编译链\n      Toolchain type (External toolchain)  --->\n        x   ( ) Buildroot toolchain\n        x   (X) External toolchain\n\n      Toolchain (Custom toolchain)\n      Toolchain origin (Pre-installed toolchain)\n      Toolchain path --->\n          /opt/gcc-linaro-7.5.0-2019.12-x86_64_arm-linux-gnueabihf/\n      Toolchain prefix --->\n          $(ARCH)-linux-gnueabihf \n\n      ##因为前面安装的是7.5的交叉编译链\n      External toolchain gcc version (7.x)\n\n      #编译链使用内核版本，查看路径：arm-linux-gnueabihf/libc/usr/include/linux/version.h\n      版本解析：4.6(263680=0x040600, 即4.6.0)\n      7.5交叉编译链的内核版本为4.10\n      External toolchain kernel headers series (4.10.x)\n\n      External toolchain C library (glibc/eglibc)\n      ```\n  3. 编译 `make`\n  4. 解压到SD卡第二分区\n      `tar -xvf output/images/rootfs.tar -C /media/xsx/rootfs/`\n\n## 上电验证\n  插上SD卡，上电后，即可看到进入系统"}, "/note/Linux/Licheepi_Zero/说明.html": {"title": "说明", "content": "---\ntitle: 说明\ntags: 说明\nkeywords: 说明\ndesc: 说明\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_zero/desc/\n---\n\n## 说明"}, "/note/Linux/Licheepi_Zero/驱动/GPIO驱动/系统自带驱动.html": {"title": "系统自带LED驱动", "content": "---\ntitle: 系统自带LED驱动\ntags: LED驱动\nkeywords: LED驱动\ndesc: LED驱动\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_zero/driver/led/linux/\n---\n\n## 1. 打开系统自带LED驱动支持\n    make ARCH=arm menuconfig\n    Device Drivers --> LED Support --> LED Support for GPIO connected LED\n\n## 2. 添加设备树\n    leds {  //节点名称可自定义\n\t\tcompatible = \"gpio-leds\";   //匹配属性固定\n\n\t\tblue_led {\n\t\t\tlabel = \"blue\";\n\t\t\tgpios = <&pio 6 1 GPIO_ACTIVE_LOW>; /* PG1\n\t\t};\n\n\t\t/*green_led {\n\t\t\tlabel = \"green\";\n\t\t\tgpios = <&pio 6 0 GPIO_ACTIVE_LOW>; // PG0\n\t\t\tdefault-state = \"on\";\n\t\t};\n\n\t\tred_led {\n\t\t\tlabel = \"red\";\n\t\t\tgpios = <&pio 6 2 GPIO_ACTIVE_LOW>; // PG2\n\t\t};*/\n\t};\n    因以上设备树内容在sun8i-v3s-licheepi-zero.dtsi中定义，该设备树为zero通用模板，会被最终设备树文件sun8i-v3s-licheepi-zero-dock.dts引用，故上面的内容不用添加，只需要在sun8i-v3s-licheepi-zero-dock.dts中将对应的节点打开即可\n    sun8i-v3s-licheepi-zero-dock.dts：\n    leds {\n\t\tblue_led {\n\t\t\tstatus = \"okay\";\n\t\t};\n\n\t\tgreen_led {\n\t\t\tstatus = \"disabled\";\n\t\t};\n\n\t\tred_led {\n\t\t\tstatus = \"disabled\";\n\t\t};\n\t};\n\n## 3. 编译\n    make ARCH=arm licheepi_zero_defconfig\n    make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j8\n\n## 4. 下载系统\n将`arch/arm/boot/zImage`和`arch/arm/boot/dts/sun8i-v3s-licheepi-zero-dock.dtb`复制到SD卡的第一分区即可\n\n## 5. 验证\n    echo 1 > /sys/class/leds/blue/brightness \n    echo 0 > /sys/class/leds/blue/brightness"}, "/note/Linux/Licheepi_Zero/驱动/GT911驱动.html": {"title": "V3S添加GT911驱动", "content": "---\ntitle: V3S添加GT911驱动\ntags: GT911\nkeywords: GT911\ndesc: V3S添加GT911驱动\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_zero/driver/touch/gt911/\n---\n\n## 一、在linux源码中添加gt911驱动\n### 1.1、添加gt911驱动源码\ndrivers/input/touchscreen/gt911.c\n```\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_irq.h>\n#include <linux/interrupt.h>\n#include <linux/input.h>\n#include <linux/input/mt.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/gpio.h>\n#include <linux/of_gpio.h>\n#include <linux/input/mt.h>\n#include <linux/input/touchscreen.h>\n#include <linux/i2c.h>\n\n\n\n/**\n * file name：gt9xx\n * date: 2021-09-01  15:04\n * version：1.0\n * author:luatao\n * describe：gt9xx device drive\n */\n#define GT_CTRL_REG \t            0X8040  /* GT9147控制寄存器         */\n#define GT_MODSW_REG \t        0X804D  /* GT9147模式切换寄存器        */\n#define GT_CFGS_REG \t        0X8047  /* GT9147配置起始地址寄存器    */\n#define GT_CHECK_REG \t        0X80FF  /* GT9147校验和寄存器       */\n#define GT_PID_REG \t\t        0X8140  /* GT9147产品ID寄存器       */\n\n#define GT_GSTID_REG \t        0X814E  /* GT9147当前检测到的触摸情况 */\n#define GT_TP1_REG \t\t        0X814F  /* 第一个触摸点数据地址 */\n#define GT_TP2_REG \t\t        0X8157\t/* 第二个触摸点数据地址 */\n#define GT_TP3_REG \t\t        0X815F  /* 第三个触摸点数据地址 */\n#define GT_TP4_REG \t\t        0X8167  /* 第四个触摸点数据地址  */\n#define GT_TP5_REG \t\t        0X816F\t/* 第五个触摸点数据地址   */\n#define MAX_SUPPORT_POINTS      5       /* 最多5点电容触摸 */\n\n\n/* 设备结构体 自定义 */\nstruct gt911_dev{\n    int irq_pin, reset_pin;   /* 中断和复位IO */\n    int irqnum;   /* 中断号 */\n  //  void *private_date;  /* 私有数据 */\n    struct input_dev *input;  /* input结构体 */\n    struct i2c_client *client; /* i2c客户端 */\n };\n\n/* 定义一个设备结构体 */\nstruct gt911_dev gt911;   /*gt911 设备 */\n/*\nconst unsigned char GT911_CT[]=\n{\n                                0x5A,0x20,0x03,0xE0,0x01,0x05,0x3D,0x00,0x02,0x08,0x28,\n                                0x08,0x5A,0x46,0x03,0x05,0x00,0x00,0x00,0x00,0x00,0x00,\n                                0x04,0x04,0x04,0x04,0x03,0x88,0x29,0x0A,0x4B,0x4D,0x0C,\n                                0x08,0x00,0x00,0x00,0x21,0x02,0x1D,0x00,0x01,0x00,0x00,\n                                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x64,0x94,0xD5,\n                                0x02,0x07,0x00,0x00,0x04,0x83,0x48,0x00,0x77,0x4D,0x00,\n                                0x6D,0x53,0x00,0x64,0x59,0x00,0x5A,0x60,0x00,0x5A,0x00,\n                                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n                                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n                                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n                                0x00,0x00,0x02,0x04,0x06,0x08,0x0A,0x0C,0x0E,0x10,0x12,\n                                0x14,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,\n                                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n                                0x02,0x04,0x06,0x08,0x0F,0x10,0x12,0x16,0x18,0x1C,0x1D,\n                                0x1E,0x1F,0x20,0x21,0x22,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,\n                                0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n                                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD6,0x01,\n};*/\n\n\n/* 从gt911读取多个寄存器数据 \n @param - *dev        : gt911设备 \n @param - reg           : 要读取的寄存器首地址\n @param - *buf         : 读取到的数据 \n @param - len          : 要读取的数据长度 \n @return                    :操作结果\n*/\nstatic int gt911_read_regs(struct gt911_dev *dev, u16 reg, u8 *buf, int len)\n{\n    int ret = 0;\n    u8 regdata[2]; // 寄存器数据\n    struct i2c_msg msg[2];   /* 传输的消息 读的命令 */\n    struct i2c_client *client = (struct i2c_client *)dev->client;  /* 私有数据 */\n\n    /* gt911 寄存器长度为2个字节 */\n    regdata[0] = (reg >> 8) & 0xFF;  // 高8位\n    regdata[1] = reg & 0xFF;  // 低8位 \n\n    /* msg[0] 为发送要读取的首地址 */\n    msg[0].addr = client->addr;  /* 器件地址 */\n    msg[0].flags = 0;                       /* 标记为发送数据 */\n    msg[0].buf = &regdata[0];              /* 要读取数据的首地址 */\n    msg[0].len = 2;                     /* reg长度 */\n\n    /* msg[1]读取数据 */\n    msg[1].addr = client->addr;  /* 器件地址 */\n    msg[1].flags = I2C_M_RD;    /* 标记为读取数据 */\n    msg[1].buf = buf;              /* 读取数据缓冲区  */\n    msg[1].len = len;                     /* 读取数据长度 */\n\n    ret = i2c_transfer(client->adapter, msg, 2);  /* 向总线发送2个消息 */\n    if(ret == 2){  /* 传输成功 */\n        ret = 0;\n    }else{\n        printk(\"i2c_transfer failed!\\r\\n\");\n        return -EREMOTEIO;\n    }\n\n    return ret;\n}\n\n/* 从gt911多个寄存器写入数据 \n @param - *dev        : gt911设备 \n @param - reg           : 要写入的寄存器首地址\n @param - *buf         : 写入的数据缓冲区\n @param - len          : 要写入的数据长度 \n @return                    :操作结果\n*/\nstatic s32 gt911_write_regs(struct gt911_dev *dev, uint16_t reg, uint8_t *buf, int len)\n{\n    uint8_t buf1[256];\n    struct i2c_msg msg;   /* 传输的消息 */\n    struct i2c_client *client = (struct i2c_client *)dev->client;  \n    buf1[0] = (reg >> 8) & 0xFF;  /* 寄存器首地址 */\n    buf1[1] = reg & 0xFF;  \n    memcpy(&buf1[2], buf, len);  /* 要写入的数据拷贝到数据buf1中 */\n    \n    /* msg处理数据 */\n    msg.addr = client->addr;  /* 器件地址 */\n    msg.flags = 0;    /* 标记为写入数据 */\n    msg.buf = buf1;              /* 要写入的数据缓冲区  */\n    msg.len = len + 2;                     /* 写入的数据长度 */\n\n    return  i2c_transfer(client->adapter, &msg, 1);  /* 向总线发送1个消息 */\n}\n\n\n/* 从gt911读取指定寄存器值 读取一个寄存器\n @param - *dev        : ap3216设备 \n @param - reg           : 要读取的寄存器\n @return                    :读取到的寄存器值\n*/\n\n//static unsigned char  gt911_read_reg(struct gt911_dev *dev, u8 reg)\n//{\n  // struct i2c_client *client = (struct i2c_client *)dev->client;  /* 私有数据 */\n\n\t//return i2c_smbus_read_byte_data(client, reg);  /* 读取一个字节数据 */\n//}\n\n/* 向gt911指定寄存器写入指定的值，写一个寄存器 \n @param - *dev        : ap3216设备 \n @param - reg           : 要写入的寄存器\n @param - data         : 要写入的值 \n @return                    :无\n*/\nstatic void gt911_write_reg(struct gt911_dev *dev, uint16_t reg, uint8_t data)\n{\n    uint8_t buf = 0;\n\tbuf = data;\n\tgt911_write_regs(dev, reg, &buf, 1);  /* 调用写入多个寄存器的方法 */\n}\n\n/* 触摸中断处理函数 */\nstatic irqreturn_t gt911_irq_handler(int irq, void *dev_id)\n{\n    u8 touch_num = 0, status, havakey ; // 触摸点的数量最大5点触摸  数据是否准备好  是否有按键按下 \n    int input_x, input_y, id = 0;  // x，y坐标  触摸ID\n    int ret = 0;  // 返回值\n    u8 data,touch_data[5];  // 触摸数据\n    struct gt911_dev *dev = dev_id; // 触摸设备结构体\n\n    /* 判断是否进入中断 */\n    //printk(\"cd %s\\r\\n\",__FUNCTION__);\n\n    /* 读取坐标点寄存器 */\n    ret = gt911_read_regs(dev, GT_GSTID_REG, &data, 1); \n    /* 这一位数据的表示：\n       bit7：1表示坐标（或按键）已经准备好，主控可以读取  0 表示未就绪，数据无效\n       bit4：1表示有按键 0表示无按键（已经松开）\n       bit3~0：屏上的坐标点个数  */\n    if(data == 0x00){  /* 没有触摸数据*/\n        goto fail;\n    }else{  /* 统计触摸信息 */\n        status = data >> 7;  // 取最高位 \n        havakey = (data >> 4) & 0x01; \n        touch_num = data & 0x0f;  // 只取低4位 \n    }\n\n    /* 单点触摸 不适用于多点触摸*/\n    if(touch_num){  /* 有触摸按下   */\n        gt911_read_regs(dev, GT_TP1_REG, touch_data, 5);  // 读取第一个触摸点 连续读5个数据 \n        id = touch_data[0] & 0x0F; \n        if(id == 0){\n            input_x = (touch_data[1] | (touch_data[2] << 8)) & 0x0fff;  // x坐标\n            input_y = (touch_data[3] | (touch_data[4] << 8)) & 0x0fff;  // y坐标\n\n            input_mt_slot(dev->input, id); // 产生ABS_MT_SLOT 事件 报告是哪个触摸点的坐标 \n            input_mt_report_slot_state(dev->input, MT_TOOL_FINGER, true);   // 指定手指触摸  连续触摸\n            input_report_abs(dev->input, ABS_MT_POSITION_X, input_x);   // 上报触摸点坐标信息 \n            input_report_abs(dev->input, ABS_MT_POSITION_Y, input_y);   // 上报触摸点坐标信息 \n\n            //printk(\"x = %d, y = %d\\r\\n\", input_x, input_y);  //打印坐标信息 \n        }\n    }else if(touch_num == 0){  // 单点触摸释放 \n        input_mt_slot(dev->input, id); /* 上报触摸点 */\n        input_mt_report_slot_state(dev->input, MT_TOOL_FINGER, false); // 关闭手指触摸 \n    }\n\n        input_mt_report_pointer_emulation(dev->input, true); \n        input_sync(dev->input);   /* 同步数据 数据上报完成 */\n\n        data = 0x00;  /* 向0x814E寄存器写0  不然就会一直进入中断 */\n        gt911_write_regs(dev, GT_GSTID_REG, &data, 1);   //写入\n\nfail:\n    return IRQ_HANDLED;\n}\n\n/* 申请IO并复位gt911 \n @param - *client           : i2C控制器\n @param - *dev         : 自定义的触摸设备\n @return                    :0：成功             其他负值 ：失败\n*/\nstatic int gt911_ts_reset(struct i2c_client * client, struct gt911_dev *dev)\n{\n    int ret = 0;\n    printk(\"cd %s\\r\\n\",__FUNCTION__);\n    /* 申请复位IO */\n    if(gpio_is_valid(dev->reset_pin)){  // 判断gpio是否合法\n    /* 申请复位 IO  并且默认输出高电平 */\n        ret = devm_gpio_request_one(&client->dev,     \n                                                                        dev->reset_pin,\n                                                                        GPIOF_OUT_INIT_LOW,\n                                                                        \"gt911 reset\");\n        if(ret){  // 申请失败\n            printk(\"request reset_pin failed!\\r\\n\");\n             return ret;\n        }\n    }\n\n    /* 申请中断IO*/\n     if(gpio_is_valid(dev->irq_pin)){  // 判断gpio是否合法\n    /* 申请复位 IO  并且默认输出高电平 */\n        ret = devm_gpio_request_one(&client->dev,     \n                                                                        dev->irq_pin,   //  引脚编号\n                                                                        GPIOF_OUT_INIT_LOW,   // 默认的电平状态 \n                                                                        \"gt911 irq\");  // 名字 随便\n        if(ret){  // 申请失败\n            printk(\"request irq_pin failed!\\r\\n\");\n             return ret;\n        }\n    }\n\n    /* 初始化gt911  */\n    gpio_set_value(dev->reset_pin, 0); /* 复位 */\n    msleep(10);\n    gpio_set_value(dev->reset_pin, 1); /* 停止复位 */\n    msleep(10);\n    gpio_set_value(dev->irq_pin, 0);    /* 拉低INT引脚 */\n    msleep(50);\n    gpio_direction_input(dev->irq_pin); /* INT引脚设置为输入 */\n\n    /* 有一个地址的判断 */\n\n\treturn 0;\n}\n\n/* gt911 中断初始化 \n @param - *client           : i2C控制器\n @param - *dev         : 自定义的触摸设备\n @return                    :0：成功             其他负值 ：失败\n*/\nstatic int gt911_ts_irq(struct i2c_client * client, struct gt911_dev *dev)\n{\n    int ret = 0; // 返回值\n\n    /* 申请中断  */\n    ret = devm_request_threaded_irq(&client->dev,\n                                                                            client->irq,\n                                                                            NULL,\n                                                                            gt911_irq_handler,\n                                                                            IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n                                                                            client->name,\n                                                                            &gt911);\n    if(ret){\n        dev_err(&client->dev, \"Unable to request touchscreen IRQ.\\r\\n\");\n        return ret;\n    }\n\n    printk(\"gt911 handler irq number: %d\\r\\n\", client->irq);  // 打印出中断号\n    return 0;\n}\n\n/* 发送gt911配置参数 \n @param - *dev           : 自定义的触摸设备\n @param - mode         : 0 :参数不保存到flash  1：参数保存到flash\n @return                    :无\n*/\n/* 屏幕配置信息  */\n/*\nvoid gt911_send_cfg(void)\n{\n    u8 regdata[186] = {0};\n    unsigned int i = 0,ret = 0;\n    u8 softVersion = 0;  // 软件版本号 \n    u8 gt911_id[6] = {0}; // 产品ID\n    u8 irqmode = 0;  // 中断触发方式\n    u8 crc = 0;  // 校验和 \n\n    //  读软件版本号 \n    gt911_read_regs(&gt911, GT_CFGS_REG, &softVersion,1); \n    printk(\"soft version:%d\\r\\n\", softVersion);\n\n    // 读取产品ID \n    printk(\"ID: \");\n    gt911_read_regs(&gt911, GT_PID_REG, gt911_id,6); \n    for(i = 0; i< 6;i++)\n        printk(\"%d \", gt911_id[i]);\n\n    printk(\"\\r\\n\");\n\n    // 读中断触发方式 \n    gt911_read_regs(&gt911, GT_MODSW_REG, &irqmode,1); \n    printk(\"irqmode:%d\\r\\n\", irqmode);\n\n    // 读取184个寄存器 \n    gt911_read_regs(&gt911, GT_CFGS_REG, regdata,184); \n    for(i= 0; i < 186; i++){\n        printk(\"%#X \", regdata[i]);\n        if(i < 184){\n            crc += regdata[i];  // 校验和 \n        }\n    }\n    printk(\"\\r\\n\");\n    crc = (~crc) + 1;\n    printk(\"crc:%d\\r\\n\", crc);\n\n    // 软件复位 \n    gt911_write_reg(&gt911, GT_CTRL_REG, 2);\n\n    // 配置186个寄存器 \n    // 获取设备树的配置信息 \n    ret = of_property_read_u8_array(gt911.client->dev.of_node, \"goodix,cfg-group0\", regdata, 186);\n    if (ret < 0) {\n        printk(\"goodix,cfg-group0 property read failed\\r\\n\");\n    } else {\n        printk(\"reg data:\\r\\n\");\n        for(i = 0; i < 186; i++){\n            printk(\"%X \", regdata[i]);\n        }\n        printk(\"\\r\\n\");\n    }\n\n    gt911_write_regs(&gt911, GT_CFGS_REG, regdata, sizeof(regdata));  \n    gt911_write_reg(&gt911,GT_CTRL_REG,2);\n\n    msleep(100);\n}\n*/\n\n\n\n/* i2C驱动的probe函数 ，当驱动与设备匹配以后此函数就会执行 */\nstatic int gt911_probe(struct i2c_client *client, const struct i2c_device_id *id)\n{\n    u8 ret = 0; \n    gt911.client = client; \n    printk(\"gt911 driver and device has match!\\r\\n\");  // 提示信息 \n\n    /* 1. 获取设备树中的中断和复位引脚 */\n    gt911.irq_pin = of_get_named_gpio(client->dev.of_node, \"irq-gpio\", 0);\n\tgt911.reset_pin = of_get_named_gpio(client->dev.of_node, \"rst-gpio\", 0);\n\n    printk(\"get gpios success!\\r\\n\");\n\n    /* 2. 复位gt911 申请GPIO并复位 */\n    ret = gt911_ts_reset(client, &gt911);\n    if(ret < 0){\n        printk(\"gt911 reset failed!\\r\\n\");\n        goto fail;\n    }\n\n    /* 3. 初始化gt911 */\n    gt911_write_reg(&gt911, GT_CTRL_REG, 2);  /* 软复位 */\n    mdelay(100);\n    gt911_write_reg(&gt911, GT_CTRL_REG, 0);  /* 停止软复位 */\n    mdelay(100);\n\n    /* 4. input 注册设备*/\n    gt911.input  = devm_input_allocate_device(&client->dev);\n    if(!gt911.input){\n        return -ENOMEM;\n    }\n\n    /* 初始化input */\n    gt911.input->name = client->name;\n    gt911.input->id.bustype = BUS_I2C;\n    gt911.input->dev.parent = &client->dev;\n    /* 设置input设备需要上报事件类型和按键值*/\n    __set_bit(EV_KEY, gt911.input->evbit);\n\t__set_bit(EV_ABS, gt911.input->evbit);\n\t__set_bit(BTN_TOUCH, gt911.input->keybit);\n    /* 设置input设备 需要上报的绝对坐标 */\n    input_set_abs_params(gt911.input, ABS_X, 0, 800, 0, 0);\n\tinput_set_abs_params(gt911.input, ABS_Y, 0, 480, 0, 0);\n\tinput_set_abs_params(gt911.input, ABS_MT_POSITION_X,0, 800, 0, 0);\n\tinput_set_abs_params(gt911.input, ABS_MT_POSITION_Y,0, 480, 0, 0);\t     \n    /* 初始化多点电容触摸的slots*/\n\tret = input_mt_init_slots(gt911.input, MAX_SUPPORT_POINTS, 0);  // 初始化 MT 的输入 slots  触摸点的数量\n    if(ret != 0){\n        printk(\"MT init failed!\\r\\n\");\n        goto fail;\n    }\n\n    /* 注册input */\n    ret = input_register_device(gt911.input);\n    if(ret){\n        printk(\"input register failed!\\r\\n\");\n        goto fail;\n    }\n\n    /* 最后初始化中断 */\n    ret = gt911_ts_irq(client, &gt911);\n    if(ret < 0){\n        printk(\"init irq failed!\\r\\n\");\n        goto fail;\n    }\n    return 0;\n\nfail:\n    return ret;\n}\n\n/* i2c驱动后的remove函数 */\nint gt911_remove(struct i2c_client *client)\n{\n    /* 释放输入设备 */\n    input_unregister_device(gt911.input);\n\n    printk(\"gt911 drive unregsister ok !\\r\\n\");\n    return 0;\n}\n\n/* 传统匹配方式ID列表 */\nstatic const struct i2c_device_id gt911_id[] = {\n    {\"goodix,gt911\", 0},\n    {}\n};\n/* 匹配列表 */\nstatic const struct of_device_id gt911_of_match[] = {\n    {.compatible = \"goodix,gt911\"},\n    {/* Sentinel */}\n};\n\n/* i2c驱动结构体 */\nstruct i2c_driver gt911_i2c_driver = {\n        .driver = {\n            .owner = THIS_MODULE,\n            .name = \"gt911\",   /* 驱动名字 用于和设备匹配  适用于没有设备树的情况*/\n            .of_match_table =gt911_of_match,  /* 设备树匹配列表 */\n        },\n        .probe =gt911_probe,\n        .remove =gt911_remove,\n        .id_table = gt911_id, /* id配置列表 */\n};\n\n\nmodule_i2c_driver(gt911_i2c_driver);\n\n/* LICENSE 和 AUTHOR 信息*/\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"luatao\");\n```\n修改drivers/input/touchscreen/makefile\n`obj-y\t+= gt911.o`\n\n### 1.2、修改设备树\n去掉设备树中其他I2C0的设备节点\n```\narch/arm/boot/dts/sun8i-v3s-licheepi-zero.dts\n/*\n&i2c0 {\n\tstatus = \"okay\";\n\n\tns2009: ns2009@48 {\n\t\tcompatible = \"nsiway,ns2009\";\n\t\treg = <0x48>;\n\t\tstatus = \"disabled\";\n\t};\n};\n*/\n```\n\n添加gt911节点\n```\narch/arm/boot/dts/sun8i-v3s-licheepi-zero-dock.dts\n&i2c0 {\n\tstatus = \"okay\";\n\n\tgt911: touchscreen@5d {\n        compatible = \"goodix,gt911\";\n        reg = <0x5d>;\n        interrupt-parent = <&pio>;\n        interrupts = <1 3 IRQ_TYPE_EDGE_FALLING>; /* (PB3) */\n        pinctrl-names = \"default\";\n        irq-gpio = <&pio 1 3 GPIO_ACTIVE_HIGH>; /* (PB3) */\n        rst-gpio = <&pio 1 2 GPIO_ACTIVE_HIGH>; /* RST (PB2) */\n\t\tstatus = \"okay\";\n        /* touchscreen-swapped-x-y */\n    };\n};\n```\n\n### 1.3、编译linux\n拷贝zimage和sun8i-v3s-licheepi-zero-dock.dtb到sd卡第一分区\n\n## 二、移植tslib\n### 2.1、在buildroot中打开tslib\n 在buildroot中打开tslib\n```\n make menuconfig\n Target packages —>\n        Graphic libraries and applications (graphic/text) —>\n            [*] Qt5 —>\n                [*] Enable Tslib support\n```\n### 2.2、编译buildroot\n    ```\n    make\n\n    #解压文件系统到第二分区\n    tar -xvf output/images/rootfs.tar -C /media/xsx/rootfs/\n    ```\n\n## 三、目标板上配置环境\n### 3.1、添加tslib环境变量\n修改/etc/profile\n```\nvi /etc/profile\n\nexport T_ROOT=/usr/tslib4arm                        \t\t#目录\nexport TSLIB_TSDEVICE=/dev/input/event1                     #触摸屏设备文件\nexport TSLIB_CALIBFILE=/etc/pointercal                \t\t#指定触摸屏校准文件pintercal的存放位置\nexport TSLIB_CONFFILE=/etc/ts.conf             \t\t\t\t#tslib模块配置文件\nexport TSLIB_PLUGINDIR=/usr/lib/ts/                \t\t\t#tslib插件库目录\nexport TSLIB_CONSOLEDEVICE=/dev/tty\nexport TSLIB_FBDEVICE=/dev/fb0                        \t\t#framebuffer设备文件\n```\n使生效\n`source /etc/profile`\n测试\n`ts_test`\n![](../assets/images/gt911.png)\n发现触摸不准，可校准\n`ts_calibrate`\n校准之后，可再次测试，发现触摸已准"}, "/note/Linux/Licheepi_Zero/驱动/GPIO驱动/GPIO子系统.html": {"title": "基于GPIO子系统的LED驱动", "content": "---\ntitle: 基于GPIO子系统的LED驱动\ntags: LED驱动\nkeywords: LED驱动\ndesc: LED驱动\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_zero/driver/led/gpio/\n---\n\n## 1. 驱动系统自带LED驱动\n    ##全部disabled\n    leds {\n\t\tblue_led {\n\t\t\tstatus = \"disabled\";\n\t\t};\n\n\t\tgreen_led {\n\t\t\tstatus = \"disabled\";\n\t\t};\n\n\t\tred_led {\n\t\t\tstatus = \"disabled\";\n\t\t};\n\t};\n\n## 2. 添加自定义led节点\n    bingpi_led_in_gpio {\n\t\tcompatible = \"xsx,bingpi_gpio\";\n\t\tled-gpios = <&pio 6 1 GPIO_ACTIVE_LOW>; /* PG1 */\n\t\tstatus = \"okay\";\n\t};\n\n## 3. 添加驱动\n> driver/leds/led_bingpi_in_gpio.c\n```\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/gpio.h>\n\nstatic dev_t led_dev_num; // 定义一个设备号\nstatic struct cdev *led_cdev; // 定义一个设备管理结构体指针\nstatic struct class *led_class; // 定义一个设备类\nstatic struct device *led_device; // 定义一个设备\n\nstruct gpio_desc *led_pin;\n\nstatic int led_open(struct inode *inode, struct file *file)\n{\n\tgpiod_direction_output(led_pin, 0);\n\treturn 0;\n}\n\nstatic int led_close(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}\n\nstatic int led_read(struct file *filp, char __user *buff, size_t count,\n\t\t    loff_t *off)\n{\n\tint res;\n\tsize_t status = gpiod_get_value(led_pin);\n\n\t// 将内核空间数据拷贝到用户空间\n\t// statue => buff, 大小4字节\n\tres = copy_to_user(buff, &status, 4);\n\tif (res < 0)\n\t\tprintk(KERN_DEBUG \"read error!!!\\r\\n\");\n\telse\n\t\tprintk(KERN_DEBUG \"read ok!!!\\r\\n\");\n\n\treturn res;\n}\n\nstatic int led_write(struct file *filp, const char __user *buff, size_t count,\n\t\t     loff_t *offp)\n{\n\tint res = 0;\n\tsize_t statue = 0;\n\n\tres = copy_from_user(&statue, buff, 4);\n\tif (res < 0) {\n\t\tprintk(KERN_DEBUG \"write error!!!\\r\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!!statue)\n\t\tgpiod_set_value(led_pin, 1);\n\telse\n\t\tgpiod_set_value(led_pin, 0);\n\n\treturn 1;\n}\n\nstatic struct file_operations led_ops = {\n\t.owner = THIS_MODULE,\n\t.open = led_open,\n\t.read = led_read,\n\t.write = led_write,\n\t.release = led_close,\n};\n\nstatic int led_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tint ret;\n\n\tled_cdev = cdev_alloc(); //动态申请一个设备结构体\n\tif (led_cdev == NULL) {\n\t\tprintk(KERN_WARNING \"cdev alloc fail!!\\r\\b\");\n\t\treturn -1;\n\t}\n\n\tret = alloc_chrdev_region(&led_dev_num, 0, 1,\n\t\t\t\t  \"led_bingpi_gpio\"); //动态申请一个设备号\n\tif (ret != 0) {\n\t\tprintk(KERN_WARNING \"alloc_chrdev_region fail!!\\r\\b\");\n\t\treturn -2;\n\t}\n\n\tled_cdev->owner = THIS_MODULE;\n\tled_cdev->ops = &led_ops;\n\tcdev_add(led_cdev, led_dev_num, 1); //将设备添加到内核中\n\n\tled_class = class_create(THIS_MODULE, \"led_bingpi_gpio_class\");\n\tif (led_class == NULL) {\n\t\tprintk(KERN_WARNING \"class_create fail!!\\r\\b\");\n\t\treturn -3;\n\t}\n\n\tled_device = device_create(led_class, NULL, led_dev_num, NULL,\n\t\t\t\t   \"led_bingpi_gpio\");\n\tif (IS_ERR(led_device)) {\n\t\tprintk(KERN_WARNING \"device_create fail!!\\r\\b\");\n\t\treturn -4;\n\t}\n\n\tled_pin = devm_gpiod_get(&pdev->dev, \"led\", GPIOF_OUT_INIT_LOW);\n\tif (IS_ERR(led_pin)) {\n\t\tprintk(KERN_ERR \"Get gpio resource failed!\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int led_remove(struct platform_device *pdev)\n{\n\tdevm_gpiod_put(&pdev->dev, led_pin);\n\n\treturn 0;\n}\n\nstatic struct of_device_id led_match_table[] = {\n\t{\n\t\t.compatible = \"xsx,bingpi_gpio\",\n\t},\n\t{},\n};\n\nstatic struct platform_device_id led_device_ids[] = {\n\t{\n\t\t.name = \"bingpi_gpio\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver led_driver={\n    .probe = led_probe,\n    .remove = led_remove,\n    .driver = {\n        .name = \"led_gpio\",\n        .of_match_table = led_match_table,\n    },\n    .id_table = led_device_ids,\n};\n\nmodule_platform_driver(led_driver);\n\nMODULE_LICENSE(\"GPL\"); //不加的话加载会有错误提醒\nMODULE_AUTHOR(\"1477153217@qq.com\"); //作者\nMODULE_VERSION(\"0.1\"); //版本\nMODULE_DESCRIPTION(\"led_driver\"); //简单的描述\n\n```\n\n## 4. 修改makefile\n> obj-y\t\t+= led_bingpi_in_gpio.o\n\n## 5. 编译后下载验证\n设备路径：/dev/led_bingpi_gpio，存在即表明驱动注册成功\napp验证：`./led_test_app.o /dev/led_bingpi_gpio 10`\n现象：LED闪10次"}, "/note/Linux/Licheepi_Zero/驱动/GPIO驱动/Platform驱动模型.html": {"title": "基于Platform的LED驱动", "content": "---\ntitle: 基于Platform的LED驱动\ntags: LED驱动\nkeywords: LED驱动\ndesc: LED驱动\ndate: 2023-02-01 14:17:13\npermalink: /pages/licheepi_zero/driver/led/platform/\n---\n\n## 编写设备树\n\n```\nbingpi_led {\n\t\tcompatible = \"xsx,bingpi\";\n\t\t#address-cells = <1>;\n\t\t#size-cells = <1>;\n\t\treg = <0X01C208D8 0x04 0X01C208E8 0x04>;\n\t\tstatus = \"okay\";\n\t};\n```\n\n## 编写驱动\n\n```\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/cdev.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n\nstatic dev_t led_dev_num;         // 定义一个设备号\nstatic struct cdev *led_cdev;     // 定义一个设备管理结构体指针\nstatic struct class *led_class;   // 定义一个设备类\nstatic struct device *led_device; // 定义一个设备\n\nvolatile unsigned long *gpio_cfg0;\nvolatile unsigned long *gpio_data;\n\nstatic int led_open(struct inode *inode, struct file *file)\n{\n    *((volatile size_t *)gpio_cfg0) &= ~(7 << 4); // 清除配置寄存器\n    *((volatile size_t *)gpio_cfg0) |= (1 << 4);  // 配置GPIOE10为输出模式\n\n    return 0;\n}\n\nstatic int led_close(struct inode *inode, struct file *file)\n{\n    return 0;\n}\n\nstatic int led_read(struct file *filp, char __user *buff, size_t count, loff_t *off)\n{\n    int res;\n    size_t status = *((volatile size_t *)gpio_data);\n\n    // 将内核空间数据拷贝到用户空间\n    // statue => buff, 大小4字节\n    res = copy_to_user(buff, &status, 4);\n    if (res < 0)\n        printk(KERN_DEBUG \"read error!!!\\r\\n\");\n    else\n        printk(KERN_DEBUG \"read ok!!!\\r\\n\");\n\n    return res;\n}\n\nstatic int led_write(struct file *filp, const char __user *buff, size_t count, loff_t *offp)\n{\n    int res = 0;\n    size_t statue = 0;\n\n    res = copy_from_user(&statue, buff, 4);\n    if (res < 0)\n    {\n        printk(KERN_DEBUG \"write error!!!\\r\\n\");\n        return 0;\n    }\n\n    if (!!statue)\n        *((volatile size_t *)gpio_data) |= (1 << 1);\n    else\n        *((volatile size_t *)gpio_data) &= ~(1 << 1);\n\n    return 1;\n}\n\nstatic struct file_operations led_ops = {\n    .owner = THIS_MODULE,\n    .open = led_open,\n    .read = led_read,\n    .write = led_write,\n    .release = led_close,\n};\n\nstatic int led_probe(struct platform_device * pdev)\n{\n    struct resource * res;\n    int ret;\n\n    led_cdev = cdev_alloc();    //动态申请一个设备结构体\n    if(led_cdev == NULL) {\n        printk(KERN_WARNING \"cdev alloc fail!!\\r\\b\");\n        return -1;\n    }\n\n    ret = alloc_chrdev_region(&led_dev_num, 0, 1, \"led_num\");//动态申请一个设备号\n    if(ret != 0) {\n        printk(KERN_WARNING \"alloc_chrdev_region fail!!\\r\\b\");\n        return -2;\n    }\n\n    led_cdev->owner = THIS_MODULE;\n    led_cdev->ops = &led_ops;\n    cdev_add(led_cdev, led_dev_num, 1);    //将设备添加到内核中\n\n    led_class = class_create(THIS_MODULE, \"led_class\");\n    if(led_class == NULL) {\n        printk(KERN_WARNING \"class_create fail!!\\r\\b\");\n        return -3;\n    }\n\n    led_device = device_create(led_class, NULL, led_dev_num, NULL, \"led_bingpi\");\n    if(IS_ERR(led_device)) {\n        printk(KERN_WARNING \"device_create fail!!\\r\\b\");\n        return -4;\n    }\n\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    gpio_cfg0 = ioremap(res->start, res->end - res->start + 1);\n\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n    gpio_data = ioremap(res->start, res->end - res->start + 1);\n\n    return 0;\n}\n\nstatic int led_remove(struct platform_device * pdev)\n{\n    iounmap(gpio_cfg0);\n    iounmap(gpio_data);\n\n    cdev_del(led_cdev);\n    unregister_chrdev_region(led_dev_num, 1);\n    device_destroy(led_class, led_dev_num);\n    class_destroy(led_class);\n\n    return 0;\n}\n\nstatic struct of_device_id led_match_table[]={\n    {\n        .compatible = \"xsx,bingpi\",\n    },\n    {},\n};\n\nstatic struct platform_device_id led_device_ids[]={\n    {\n        .name=\"bingpi\",\n    },\n    {},\n};\n\nstatic struct platform_driver led_driver={\n    .probe = led_probe,\n    .remove = led_remove,\n    .driver = {\n        .name = \"led\",\n        .of_match_table = led_match_table,\n    },\n    .id_table = led_device_ids,\n};\n\nstatic int led_driver_init(void)\n{\n    platform_driver_register(&led_driver);\n\n    return 0;\n}\n\nstatic void led_driver_exit(void){\n    platform_driver_unregister(&led_driver);\n}\n\nmodule_init(led_driver_init);\nmodule_exit(led_driver_exit);\n\nMODULE_LICENSE(\"GPL\");          //不加的话加载会有错误提醒\nMODULE_AUTHOR(\"1477153217@qq.com\");     //作者\nMODULE_VERSION(\"0.1\");          //版本\nMODULE_DESCRIPTION(\"led_driver\");  //简单的描述\n\n```\n\n```\n#编译app\narm-linux-gcc led_test.c -o led_test_app.o\n\n#下载到板子上\nchmod 777 ./led_test_app.o\n./led_test_app.o /dev/led_bingpi 10\nLED即可闪烁10次\n```"}}